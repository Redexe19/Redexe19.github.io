<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lua Obfuscator — Prometheus Style</title>
  <meta name="description" content="Paste Lua code and obfuscate it into Prometheus-style obfuscated Lua." />
  <style>
    :root { --accent:#dc2626; --muted:#94a3b8; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:linear-gradient(180deg,#0f172a,#1e293b);color:#f8fafc}
    .container{max-width:980px;margin:0 auto;padding:1rem}
    header{padding:2rem 1rem;text-align:center}
    h1{margin:0 0 .25rem}
    .grid{display:grid;grid-template-columns:420px 1fr;gap:1rem}
    .card{background:#111827;border-radius:14px;padding:1rem;box-shadow:0 10px 30px rgba(2,6,23,.4)}
    textarea{width:100%;height:220px;padding:.7rem;border-radius:10px;border:1px solid #334155;background:#0b1220;color:#f8fafc;resize:vertical}
    .btns{display:flex;gap:.5rem;margin-top:.75rem}
    button{background:var(--accent);border:0;color:#fff;padding:.6rem 1rem;border-radius:10px;cursor:pointer;font-weight:700}
    .secondary{background:#334155}
    .preview{font-family:monospace;padding:.75rem;border-radius:10px;background:#071024;border:1px dashed #274155;white-space:pre-wrap;max-height:60vh;overflow:auto}
    label.small{font-size:0.9rem;margin-right:.5rem}
    footer{text-align:center;padding:1rem;color:var(--muted)}
    .mode { display:flex; gap:.4rem; align-items:center; flex-wrap:wrap; margin-top:.5rem }
    input[type="text"]{padding:.4rem .6rem;border-radius:8px;border:1px solid #223344;background:#071022;color:#fff}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Lua Obfuscator — Prometheus-style</h1>
      <div style="color:#94a3b8">XOR-based encryption + numeric storage + junk math + var rename</div>
    </header>

    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 .5rem">Input</h2>
        <label class="small" for="code">Lua Script</label>
        <textarea id="code" placeholder="Paste your Lua code here..."></textarea>

        <div class="mode">
          <label class="small"><input type="radio" name="mode" value="prometheus" checked> Prometheus (XOR encrypted)</label>
          <label class="small"><input type="radio" name="mode" value="numeric"> Numeric-escape (old)</label>
          <label class="small"><input type="radio" name="mode" value="light"> Lightweight</label>
        </div>

        <div class="mode" style="margin-top:.5rem">
          <label class="small"><input type="checkbox" id="renameVars"> Attempt local var renaming</label>
          <label class="small">XOR key: <input type="text" id="xorKey" placeholder="random" style="width:120px"></label>
          <label class="small">Chunk size: <input type="text" id="chunkSize" value="80" style="width:80px"></label>
        </div>

        <div class="btns">
          <button id="obfuscateBtn">Obfuscate</button>
          <button class="secondary" id="downloadBtn">Download .lua</button>
          <button class="secondary" id="clearBtn">Clear</button>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 .5rem">Output</h2>
        <div id="output" class="preview">Your obfuscated code will appear here.</div>
      </section>
    </div>

    <footer>
      Made with ❤️ — Prometheus-style obfuscation (local, browser-only)
    </footer>
  </div>

  <script>
    // Utilities
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    function rndId(len=6){const chars="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";let s="";for(let i=0;i<len;i++)s+=chars.charAt(Math.floor(Math.random()*chars.length));return "_" + s;}
    function dec2pad(n,len=3){ return String(n).padStart(len,"0"); }

    // XOR encrypt a JS string with numeric key (string key allowed)
    function xorEncryptBytes(str, key) {
      // key may be string; if empty, generate random key
      if (!key) key = Math.floor(Math.random()*255).toString();
      // produce an array of integers (0..255) encrypted
      const kbytes = [];
      for (let i=0;i<key.length;i++) kbytes.push(key.charCodeAt(i) & 0xFF);
      let kbLen = kbytes.length;
      const out = [];
      for (let i=0;i<str.length;i++){
        const b = str.charCodeAt(i) & 0xFF;
        const kb = kbytes[i % kbLen] || 0x55;
        out.push(b ^ kb);
      }
      return { bytes: out, keyUsed: key };
    }

    // convert array of bytes into numeric-escape sequence like \065\066\067...
    function bytesToEscapes(bytes) {
      return bytes.map(b => "\\" + dec2pad(b,3)).join("");
    }

    // chunk an 'escaped' string into pieces of bytesPer chunk
    function chunkEscaped(escapedStr, bytesPerChunk=80) {
      const tokenLen = 4; // backslash + 3 digits
      const bytes = Math.floor(escapedStr.length / tokenLen);
      const chunks = [];
      for (let i=0;i<bytes;i+=bytesPerChunk) {
        const start = i * tokenLen;
        const end = Math.min((i+bytesPerChunk)*tokenLen, escapedStr.length);
        chunks.push(escapedStr.slice(start, end));
      }
      return chunks;
    }

    // Attempt a naive local var renaming: rename words matching "local <name>" -> local <random>.
    // This is a heuristic — may break code if not careful; used only if user checks the option.
    function renameLocalVars(source) {
      // find "local <id>" patterns and replace occurrences of those ids with random names
      // keep a map
      const varRegex = /\blocal\s+([A-Za-z_][A-Za-z0-9_]*)/g;
      const names = new Map();
      let match;
      while ((match = varRegex.exec(source)) !== null) {
        const original = match[1];
        if (!names.has(original)) names.set(original, rndId(6));
      }
      // Replace whole-word occurrences of those names (avoid replacing longer identifiers)
      let out = source;
      names.forEach((newn, oldn) => {
        // use word boundaries to avoid partial matches
        const re = new RegExp("\\b" + oldn + "\\b", "g");
        out = out.replace(re, newn);
      });
      return out;
    }

    // Build Prometheus-like wrapper: store chunks of XOR-ed byte escapes in a table of strings,
    // include decoder which turns numeric escapes into bytes, XORs with key, then reconstructs code and executes.
    function buildPrometheus(source, options) {
      const chunkSize = parseInt(options.chunkSize) || 80;
      const rawKey = options.key || "";
      const enc = xorEncryptBytes(source, rawKey);
      const bytes = enc.bytes;
      const keyUsed = enc.keyUsed;

      // Map bytes -> escapes
      const escaped = bytesToEscapes(bytes);
      const chunks = chunkEscaped(escaped, chunkSize);

      // Create random names
      const T = rndId(5);
      const D = rndId(5);
      const K = rndId(5);
      const L = rndId(5);
      const J = rndId(5);
      const H = rndId(5);
      const S = rndId(5);
      const M = rndId(5);
      const junkA = rndId(5);
      const junkB = rndId(5);

      // Create table literal lines
      const tableLines = chunks.map((c,idx) => `  "${c}"${idx===chunks.length-1 ? "" : ","}`).join("\n");

      // Compose the Lua wrapper
      // - build table of escaped chunks
      // - concat them
      // - parse escapes into bytes, decrypt with keyUsed
      // - create string via char codes
      // - attempt loadstring/load, fallback with helpful error
      // - include junk math and loops to confuse static analysis
      const luaParts = [];

      luaParts.push('--[[ Prometheus-style obfuscated (XOR encrypted) ]]');
      luaParts.push('(function(...)');
      luaParts.push(`  local ${T} = {`);
      luaParts.push(tableLines);
      luaParts.push('  }');
      luaParts.push(`  -- concat chunks`);
      luaParts.push(`  local ${D} = table.concat(${T})`);

      // junk values / masks
      const mask1 = Math.floor(Math.random()*1000000) + 1111;
      const mask2 = Math.floor(Math.random()*1000000) + 2222;
      luaParts.push(`  local ${J} = ${mask1} - ${mask2}`);
      luaParts.push(`  local ${H} = (#${T} * (${mask1} % 97)) % 13`);

      // decode numeric-escape string into byte table
      luaParts.push('');
      luaParts.push('  -- parse numeric-escape sequences like \\065\\032 ...');
      luaParts.push(`  local function parse_escapes(s)`);
      luaParts.push('    local out = {}');
      luaParts.push('    for esc in s:gmatch("\\\\%d%d%d") do');
      luaParts.push('      local n = tonumber(esc:sub(2))');
      luaParts.push('      table.insert(out, n)');
      luaParts.push('    end');
      luaParts.push('    return out');
      luaParts.push('  end');

      // decrypt using key (key bytes)
      const keyLiteral = Array.from(keyUsed).map(c => "\\" + dec2pad(c.charCodeAt(0),3)).join('');
      // We'll embed the key as a numeric-escape string as well to avoid plaintext
      luaParts.push('');
      luaParts.push(`  local ${K} = "${keyLiteral}"`);
      luaParts.push('  local function key_bytes(kstr)');
      luaParts.push('    local kb = {}');
      luaParts.push('    for esc in kstr:gmatch("\\\\%d%d%d") do table.insert(kb, tonumber(esc:sub(2))) end');
      luaParts.push('    return kb');
      luaParts.push('  end');

      // get key bytes and encrypted bytes
      luaParts.push('');
      luaParts.push(`  local ${L} = key_bytes(${K})`);
      luaParts.push(`  local ${S} = parse_escapes(${D})`);
      luaParts.push('');

      // decrypt loop
      luaParts.push('  local res_tbl = {}');
      luaParts.push(`  for i=1,#${S} do`);
      luaParts.push(`    local eb = ${S}[i]`);
      luaParts.push(`    local kb = ${L}[( (i-1) % #${L} ) + 1] or 0`);
      luaParts.push('    local db = (eb ~ kb)') ; // use bitwise XOR; note: Lua 5.3 uses ~ for xor
      // If target environment doesn't have bitwise operators (older lua), fallback via arithmetic (not implemented here).
      // We'll include additional obfuscation: modulized char building
      luaParts.push('    table.insert(res_tbl, db)');
      luaParts.push('  end');

      // convert bytes to string
      luaParts.push('  local function bytes_to_str(t)');
      luaParts.push('    local chars = {}');
      luaParts.push('    for i=1,#t do chars[i] = string.char(t[i]) end');
      luaParts.push('    return table.concat(chars)');
      luaParts.push('  end');

      // produce decoded code
      luaParts.push('  local decoded = bytes_to_str(res_tbl)');

      // add junk function and loops to confuse analysis
      luaParts.push('');
      luaParts.push(`  local function ${junkA}(n)`);
      luaParts.push('    local s = 0');
      luaParts.push('    for i=1, (n%5)+3 do s = s + (i * (n%7)) end');
      luaParts.push('    return s');
      luaParts.push('  end');
      luaParts.push('');
      luaParts.push(`  local _g = ${junkA}(${H})`);
      luaParts.push('  for _i=1, (_g%3)+1 do _g = _g + 1 end');

      // loader
      luaParts.push('');
      luaParts.push('  local loader = loadstring or load');
      luaParts.push('  if not loader then');
      luaParts.push('    error("No loadstring/load available. Decoded code follows:\\n" .. decoded)');
      luaParts.push('  end');

      // execute
      luaParts.push('  loader(decoded)()');
      luaParts.push('end)()');

      return luaParts.join('\n');
    }

    // Numeric-escape builder (old)
    function buildNumeric(source, opts) {
      const escaped = (function(s){
        let out = "";
        for (let i=0;i<s.length;i++){ out += "\\" + dec2pad(s.charCodeAt(i),3); }
        return out;
      })(source);
      const chunkSize = parseInt(opts.chunkSize) || 80;
      const chunks = chunkEscaped(escaped, chunkSize);
      const tbl = chunks.map((c,idx) => `  "${c}"${idx===chunks.length-1 ? "" : ","}`).join("\n");
      const loader = rndId(6);
      return `--[[ numeric-escape wrapper ]]\nreturn(function(...) \nlocal T={\n${tbl}\n}\nlocal S=table.concat(T)\nlocal ${loader}=loadstring or load\nif not ${loader} then error("No loadstring/load available. Decoded code follows:\\n" .. S) end\n${loader}(S)()\nend)(...)`;
    }

    // Lightweight builder
    function buildLight(source, opts) {
      const escaped = (function(s){ return btoa(unescape(encodeURIComponent(s))); })(source);
      return `--[[ base64 wrapper ]]\nlocal s="${escaped}"\nlocal function b64dec(s)\n  local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  s = string.gsub(s, '[^'..b..'=]', '')\n  return (s:gsub('.', function(x) if x=='=' then return '' end local r=b:find(x)-1 local s=''; for i=5,0,-1 do s=s..(((r>>i)&1)==1 and '1' or '0') end return s end):gsub('%d%d%d%d%d%d%d%d', function(x) return string.char(tonumber(x,2)) end))\nend\nlocal code = b64dec(s)\nlocal L = loadstring or load\nif not L then error('No loadstring/load available. Decoded code follows:\\n'..code) end\nL(code)()`;
    }

    // Main UI logic
    $('#obfuscateBtn').addEventListener('click', () => {
      const src = $('#code').value || "";
      if (!src.trim()) { $('#output').textContent = "⚠️ Paste some Lua code first"; return; }

      // maybe rename locals
      const rename = $('#renameVars').checked;
      let working = src;
      if (rename) {
        try { working = renameLocalVars(working); } catch(e){ /* ignore */ }
      }

      const mode = $$('input[name="mode"]').find(r=>r.checked).value;
      const chunkSize = parseInt($('#chunkSize').value) || 80;
      const key = $('#xorKey').value || ""; // if empty, generator will make random key

      let out;
      if (mode === "prometheus") {
        out = buildPrometheus(working, { chunkSize, key });
      } else if (mode === "numeric") {
        out = buildNumeric(working, { chunkSize });
      } else {
        out = buildLight(working, {});
      }
      $('#output').textContent = out;
    });

    $('#clearBtn').addEventListener('click', ()=> { $('#code').value = ""; $('#output').textContent = "Your obfuscated code will appear here."; });

    $('#downloadBtn').addEventListener('click', () => {
      const out = $('#output').textContent;
      if (!out || out.trim().startsWith("⚠️") || out.trim() === "Your obfuscated code will appear here.") { alert("No obfuscated output — press Obfuscate first."); return; }
      const blob = new Blob([out], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = "prometheus_obf.lua"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // NodeList.find polyfill for older browsers
    if (!NodeList.prototype.find) NodeList.prototype.find = Array.prototype.find;
  </script>
</body>
</html>
